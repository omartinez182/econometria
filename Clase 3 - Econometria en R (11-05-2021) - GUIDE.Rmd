---
title: "# Clase 3 - Econometria en R (11-05-2021)"
output: rmarkdown::github_document
---

# Clase 3 - Econometria en R (11-05-2021)

```{r}
library(dplyr)
library(ggplot2)

# Cargar dataset
library(downloader)

url <- "https://raw.githubusercontent.com/omartinez182/econometria/main/Data/Advertising.csv"
filename <- "Advertising.csv"

if (!file.exists(filename)) download(url,destfile=filename)

dataset <- read.csv('Advertising.csv')
dataset

dataset <- dataset[ , c(2, 5)]
dataset
```

Ploteamos los datos de TV vs Sales.

```{r}
dataset %>%
  ggplot(aes(x=TV, y=Sales))+
  geom_point(col="blue")+
  theme_classic()
```

Vemos que esto es heteroscedeastico, pero por ahora no nos vamos a preocupar por los supuestos de "Gauss" en la regresion lineal.

```{r}
# Parametros de la funcion (Aun no la volvemos funcion, despues haremos eso)
c <- 300 #Vamos a generar 300 modelos
td <- 20 #Tamaño de la muestra (Vamos a samplear 300 veces 20 valores distintos) recordemos que en teoria no podemos utilizar toda la poblacion, pero del sampleo vamos a generar una pseudopoblacion. Haremos bootstrapping, recordemos nuestra conversacion del sampling con o sin replacement.
df <- dataset

listaX <- list() #Lista vacia
totalB0 <- 0 #Total de beta0, usamos 0 para iniciar
totalB1 <- 0 #Total de beta1, usamos 0 para iniciar

# Vamos a construir un string que tiene el codigo que usariamos para generar el plot, ya que para cada modelo le vamos a agregar una linea al plot. (Notar que esto es Codigo que genera codigo)
ggplot(aes(x=df[ , 1], y=df[ , 2]), data=df) + geom_point(col='red') #Tomamos todas las filas en la columna 1 osea TV y el target es todas las filas en la columna 2 osea Sales. No colocamos TV o Sales directamente para hacer la funcion generica.


# Recordemos la funcion eval, la cual nos ayuda a evaluar un string.
eval(parse(text="ggplot(aes(x=df[ , 1], y=df[ , 2]), data=df) +  geom_point(col='red')")) #Vamos a correr este codigo varias veces y esto nos va a resultar en una grafica con varios modelos. 

baseStr <- "ggplot(aes(x=df[ , 1], y=df[ , 2]), data=df) + geom_point(col='red')+" #Agregamos un + que nos va a servir despues.

#Vamos a generar un dataset temporal que contiene un sampleo. Generamos una muestra de tamaño 1 hasta la cantidad de filas del dataframe. td el tamaño del sampleo definido antes.
sample(1:nrow(df), td, replace = FALSE) # Esto genera 20 numero aleatorios con una dist. de probabilidad uniforme. Corramoslo varias veces para ver que pasa.

# Ahora usamos esos numeros como indices para seleccionar la muestra del dataset. Corramoslo varias veces para ver que pasa.
df[sample(1:nrow(df), td, replace = FALSE), c(1,2)]  #Le pasamos 1,2 para seleccionar las columnas

#Vamos a iterar con un for loop por la cantidad de modelos que queremos generar
for(i in c(1:c)){ #Iteramos desde 1 hasta c, la variable que definimos arriba
  temp.df <- df[sample(1:nrow(df), td, replace = FALSE), c(1,2)] #Metemos esto a nuestro for loop.
}

#Ahora usaremos la funcion lm, en la cual entraremos en mas detalle en la siguiente clase, para generar nuestros modelos lineales. 
lm(formula= df[ ,2] ~ df[ ,1], data=df) #Notar que usamos indices de columnas para mantener todo generico. Esto esta haciendo gradient descent.

#Entonces, generamos un modelo temporal, dentro del for loop.
for(i in c(1:c)){ 
  temp.df <- df[sample(1:nrow(df), td, replace = FALSE), c(1,2)]
  tempModel <- lm(formula= temp.df[ ,2] ~ temp.df[ ,1], data=temp.df) #NOTAR que aca usamos el dataset temporal temp.df
  #Ahora guardamos el modelo generado en la lista. Esto nos puede servir mas adelante.
  listaX[[i]] <- tempModel
}

#Ahora vamos a ir sumando todos los valores de B0 y B1 para poder sacar el promedio al final. Notar lo siguiente, al generar un modelo con lm, podemos acceder al attributo coefficients que tiene el intercepto en la posicion 1 (B0), y el B1 (slope/pendiente) en la posicion 2.
modelo <- lm(formula= df[ ,2] ~ df[ ,1], data=df) 
modelo$coefficients[1]

#Entonces, generamos un modelo temporal, dentro del for loop.
for(i in c(1:c)){ 
  temp.df <- df[sample(1:nrow(df), td, replace = FALSE), c(1,2)]
  tempModel <- lm(formula= temp.df[ ,2] ~ temp.df[ ,1], data=temp.df)
  listaX[[i]] <- tempModel
  # Generamos los totales de los coeficientes. El promedio de todos estos modelos sera el mas parecido al poblacional.
  totalB0 <- totalB0 + tempModel$coefficients[1]
  totalB1 <- totalB1 + tempModel$coefficients[2]
  #Ademas, vamos a extrear el B0 y B1 del modelo actual. Estos nos van a servir para las graficas.
  tempB0 <- tempModel$coefficients[1]
  tempB1 <- tempModel$coefficients[2]
  
  #Ahora vamos a generar la grafica. Es decir que vamos agregar la nueva recta, generada por los coeficientes temporales, a la grafica que solo tenia el scatter plot de las dos variables. 
  #Importante notar que paste0 nos sirve para concatenar strings. Luego usamos la geometria abline de ggplot para generar la linea (recta)
  baseStr<-paste0(baseStr, 
                    "geom_abline(slope=",
                    tempB1,
                    ", intercept=",
                    tempB0, 
                    ", col='light blue', alpha=0.2)", sep="+") #El + lo usamos como separador porque es como que utilizaramos el codigo normal en ggplot. VEAMO un ejemplo
  
}

ggplot(aes(x=df[ , 1], y=df[ , 2]), data=df) + geom_point(col='red') +
  geom_abline(slope=0.04, intercept = 7, col='blue', alpha=0.6)

# Por ultimo lo que vamos a hacer es agregar la linea (recta) global, que es el promedio de todas las anteriores.

globalB0 <- (totalB0/c) #Esto es la suma total de los B0 divido la cantidad de modelos que especificamos con c.
globalB1 <- (totalB1/c)

# Por ultimo, agregamos la nueva linea. Que es lo mismo que la linea anterior, con unas pequeñas modificaciones. No usaremos paste0, ya que esa funcion tiene un separador por default, usaremos solo paste. RECORDEMOS que el string base (baseStr) contiene todos los modelos. 
baseStr<-paste(baseStr, 
                    "geom_abline(slope=",
                    globalB1, #Cambiamos a globales
                    ", intercept=",
                    globalB0, #Cambiamos a globales
                    ", col='blue', size=1)+theme_classic()") #Cambiamos color de la linea y tamaño para verla mejor.

#Ahora si evaluamos el string.
outPlot<-eval(parse(text=baseStr))

#Declaramos una variable de salida, que sera una lista.
salida<-list(pendientePoblacional = globalB1,
               interceptoPoblacional = globalB0,
               PlotSalida = outPlot)

# AHORA EVALUEMOS SI FUNCION, CORRAMOS CIERTAS PARTES CLAVE PARA VER SI FUNCIONA. 
# DESPUES DE CORRER EL CODIGO PROBAMOS. 
salida$pendientePoblacional
salida$interceptoPoblacional
salida$PlotSalida
```

Cada linea es un modelo y la linea azul fuerte es el promedio.

NOTEMOS, que se genera un tipo de "Region" en donde estan todas las posibles rectas donde se podrian generar el modelo. 

Ahora volvemos nuestro codigo una funcion. Aca podemos borrar el c y td, ya que se lo pasaremos como funcion a los parametros.

```{r}

n_model_generator<-function(c=300, td=20, df){  
  listaX<-list()
  totalB0<-0
  totalB1<-0
  
  baseStr<-"ggplot(aes(x=df[ , 1], y=df[ , 2]), data=df) + geom_point(col='red')+"
  
  for(i in c(1:c)){
    temp.df<-df[sample(1:nrow(df), td, replace = FALSE), c(1, 2)]
    tempModel<-lm(formula = temp.df[ ,2] ~ temp.df[ , 1], data=temp.df)
    listaX[[i]]<-tempModel
    
    totalB0<-totalB0 + tempModel$coefficients[1]
    totalB1<-totalB1 + tempModel$coefficients[2]
    
    tempB0<-tempModel$coefficients[1]
    tempB1<-tempModel$coefficients[2]
    
    baseStr<-paste0(baseStr, 
                    "geom_abline(slope=",
                    tempB1,
                    ", intercept=",
                    tempB0, 
                    ", col='light blue', alpha=0.2)", sep="+")
    
  }
  
  globalB0<-(totalB0/c)
  globalB1<-(totalB1/c)
  
  baseStr<-paste(baseStr, 
                    "geom_abline(slope=",
                    globalB1,
                    ", intercept=",
                    globalB0, 
                    ", col='blue', size=1)+theme_classic()")
  
  outPlot<-eval(parse(text=baseStr))
  
  salida<-list(pendientePoblacional = globalB1,
               interceptoPoblacional = globalB0,
               PlotSalida = outPlot)
  
  return(salida)
}


# Cargar dataset
dataset<-read.csv("Advertising.csv")
dataset<-dataset[ , c(2,5)]

a<-n_model_generator(300, 20, dataset) #Asignemos el modelo a una variable
a$PlotSalida
```

Recordemos que esto solo funciona para datasets de 2 variables. Probemos con otra variables y cambiemos de 300 modelos a 1000 modelos. 

```{r}
dataset<-read.csv("Advertising.csv")
dataset<-dataset[ , c(3,5)]

b<-n_model_generator(1000, 20, dataset)
b$PlotSalida
```

Notemos que con 1000 modelos se ve mucho mas denso. Esto lo podriamos hacer para mas variables, pero en ese caso ya no podriamos visualizarlo de esta manera.

Pongamosle atencion a eval() porque en muchas ocaciones nos va a servir escribir codigo que genera codigo.
